/*
 * main_macro.C
 *
 *  Created on: Sep 21, 2016
 *      Author: fforcher
 */

//============================================================================
// Name        : bP_05.cpp
// Author      : Francesco Forcher
// Version     : 1.1
// Description : Modify Plot_v04 and use dispatcher&observers to handle begin/end job
//============================================================================
//#include "AnalysisFactory.h"
//#include "AnalysisInfo.h"
//#include "EventSource.h"
//#include "SourceFactory.h"
//#include "util/include/Dispatcher.h"
#include <iostream>
#include <vector>
#include <fstream>
#include <memory>
#include <cstdlib>
#include <unistd.h>
#include <map>
#include <sstream>
#include <array>

#include <TROOT.h>
#include <TH1.h>
#include <TFile.h>

#include "mia_dech.h"
#include "analizza_dechanneling.h"
#include "dbg_macro.h"
#include "my_typedefs.h"
#include "dech.h"

// Per poter usare questa macro sia compilando che eseguendo.
// https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#moving-between-interpreter-and-compiler
#ifndef __CLING__

#include "DatiChanneling.h"

#else
// Altrimenti includi il file della macro. Nel compilatore naturalmente direbbe multiple definition quando linka l'altro
// file.

#include "DatiChanneling.cpp"

#endif

//GLOBALS meglio in un file a parte
//Directory del progetto
TDirectory* ROOT_PROJDIR = nullptr;
char PROJECT_DIR[FILENAME_MAX] = "[NOT SET]";
std::vector<TH1*> vHistograms;
std::vector<TCanvas*> vCanvases;

int main_macro(int argc, char* argv[]) {

	using namespace std;
	using mions::FieldCrystalDataTable;
	using mions::CrystalDataTable;

	// Save the directory of the project (remember you are expected to start it from the
	// top folder of the repo)
	getcwd(PROJECT_DIR, FILENAME_MAX);
	// store command line parameters

	int argc2 = 7;
	const char* argv2[] = { "./Debug/Ronch_braggPlot_v05", "input",
			"bragg_events.txt", "hist", "hh", "ranges", "energyRanges" };

	//Elenco dei cristalli
	std::vector<const char*> elenco_cristallistf { "STF38", "STF45", "STF47",
			"STF49", "STF51" };
	std::vector<const char*> elenco_cristalliqmp { "QMP27", "QMP29", "QMP32" };
	std::vector<const char*> elenco_cristalli { "STF38", "STF45", "STF47",
			"STF49", "STF51", "QMP27", "QMP29", "QMP32" };

	std::vector<const char*> elenco_cristalli_buoni { "STF45", "STF49", "QMP27",
			"QMP32" };

	//std::vector<const char*> elenco_cristalli { "QMP32" };
	clog << "Start main_macro..." << endl;

	DBG(clog << "DEBUG VERSION " << endl; ,
	    clog << "RELEASE VERSION " << endl;)

	// Corso root lunardon/garfagnini
	// carica la macro generica che legge il file di testo
	//gROOT->LoadMacro("ReadHistoFromTextFile.C");
	//gSystem->Load("ReadHistoFromTextFile_C.so"); // altra opzione per la precompilata

	/*
	 #if defined(__ROOTCLING__)
	 #pragma link C++ class MyOtherClass;
	 #endif
	 */
	//gROOT->LoadMacro("src/mia_dech.C");
	//gSystem->AddIncludePath(" -I./src/ ");
	//gROOT->ProcessLine(".L ./src/mia_dech.C+");
	//clog << "Fin qua" << endl;
	DBG(clog << "Current Project Dir: " << PROJECT_DIR << endl
	; , ;)

	/* Chiamare mia_dech su tutti i cristalli
	 * 1. Ottenere i file recoDataSimple_546_31-59.torsion.correction.histo.root
	 *
	 * 2. Scoprire dove sono le variabili
	 * 	//xtal length and curvature TODO Controllare!
	 Double_t z = 2e-3;
	 Double_t R;
	 * per gli altri cristalli (tabella in tesi di roberto?)
	 *
	 * 3. ???
	 * 4. Profit!
	 */

	//Shared because every crystal has to use it. Maybe not the best solution...
	std::shared_ptr<std::ofstream> outputdechanneling(
			new std::ofstream("./dechanneling_table.txt",
					std::ofstream::out | std::ofstream::trunc));

	auto& outdatafile = *outputdechanneling;

	*outputdechanneling
			<< "# File generated by the macro mia_dech() for the dechanneling lenghts."
			<< endl;
	*outputdechanneling
			<< "# Crystal | dechanneling L at +-5 microrad [m] | dechanneling L at +-10 microrad [m]"
			<< endl;

	ROOT_PROJDIR = gDirectory;
	TDirectory* currentDir = gDirectory;

	std::string path_file_output_root = string(PROJECT_DIR)
			+ "/Dechanneling_Histograms.root";
	auto file_output_root = std::make_shared<TFile>(
			path_file_output_root.c_str(), "RECREATE");



	//Read crystal data
	// File format: Crystal name | Rc [m]
	CrystalDataTable map_dati_crist_orig;

	{
		string nome_file_raggio_cristallo = string(PROJECT_DIR)
				+ "/tabella_dati_cristalli.txt";
		ifstream file_raggi_cristalli(nome_file_raggio_cristallo);

		string riga_estratta;
		stringstream ss;


		// Contenuto di una riga del file
		//Ignora la prima linea con i nomi delle colonne
		std::getline(file_raggi_cristalli, riga_estratta);

		while (file_raggi_cristalli) {
			string cristallo;
			Double_t raggio_curvatura;
			Double_t bending_angle;
			Double_t thickness;

			std::getline(file_raggi_cristalli, riga_estratta);
			//cout << riga_estratta << endl;
			ss << riga_estratta;

			//TODO finire!
			// TODO Perche' i raggi di pag 88 e di pag 66 non coincidono? Che fare?
			ss >> cristallo;
			ss >> raggio_curvatura;
			ss >> bending_angle;
			ss >> thickness;

			if (cristallo != string("")) {
				DBG(clog << cristallo << ": Rc " << raggio_curvatura << " Thb " << bending_angle << endl;
				; , ;)
				//map_dati_crist[cristallo][(int)FieldCrystalDataTable::raggio_curvatura] = raggio_curvatura;
				//map_dati_crist[cristallo][(int)FieldCrystalDataTable::bending_angle] = bending_angle;

				// The other elements will be initialized to zero
				map_dati_crist_orig[cristallo] = {raggio_curvatura, bending_angle, thickness};
			}

			ss.clear();
		}
	}


	std::string path_file_output_data = string(PROJECT_DIR)
			+ "/Calculated_Crystal_Data.txt";
	//auto file_output_data = std::make_shared<TFile>(
	//		path_file_output_root.c_str(), "RECREATE");



	//Here we store the results of the analysis (ie the fit parameters)
	mions::CrystalDataTable510 map_dati_crist_calc;

	for (const auto& ch : elenco_cristalli_buoni) {
		cout << endl << endl;
		//dech(ch, outputdechanneling);
		cout << "Crystal: " << ch
				<< " Rc[m]: " << map_dati_crist_orig[ch][(int)FieldCrystalDataTable::raggio_curvatura]
				<< " Thetab[muRad]: " << map_dati_crist_orig[ch][(int)FieldCrystalDataTable::bending_angle];

		mions::mia_dech(ch, outputdechanneling, file_output_root,
				map_dati_crist_orig,map_dati_crist_calc);
		//currentDir->cd();

		outdatafile << ch << " ";
		for (auto d : map_dati_crist_calc[ch]) {
			outdatafile << d << " ";
		}

		outdatafile << endl;
		cout << endl << endl;
	}
	//file_output_root->Close();


	// TODO test
	//dech("STF45", outputdechanneling);

	cout << "Analyzed all crystals in list" << endl;




	/*
	 * Now make the file with the data for the plot Rc-Ld
	 */




	currentDir->cd();
	//mia_dech();

	//char t = 'a';
	//while (cin >> t)
	//	return 0;

	return 0;
}

